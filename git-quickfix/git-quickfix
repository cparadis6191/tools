#!/usr/bin/env sh

set -e

usage() {
	cat <<EOF
Usage:
	$(basename -- "$0") diff
	$(basename -- "$0") diffref
	$(basename -- "$0") grep
	$(basename -- "$0") show
	$(basename -- "$0") stash show
	git diff --patch --no-prefix --relative | $(basename -- "$0")
	vim -q <($(basename -- "$0") diff --staged)
	vim -q <($(basename -- "$0") stash show)
	vim -q <($(basename -- "$0") show)
EOF
}

# Adapted from mode_diff() in git-jump
diff_to_quickfix() {
	perl -ne '
	if (m{^\+\+\+ (.*)}) { $file = $1; next }
	defined($file) or next;
	if (m/^@@ .*?\+(\d+)/) { $line = $1; next }
	defined($line) or next;
	if (/^ /) { $line++; next }
	if (/^[-+]\s*(.*)/) {
		print "$file:$line: $1\n";
		$line = undef;
	}
	'
}

# Adapted from mode_grep() in git-jump
grep_to_quickfix() {
	perl -pe '
	s/[ \t]+/ /g;
	s/^ *//;
	'
}

while getopts h OPT; do
	case $OPT in
		h)
			usage

			exit 0
			;;
		*)
			{
				echo "Try '$(basename -- "$0") -h' for more information."
			} 1>&2

			exit 1
			;;
	esac
done

if [ $# -gt 0 ]; then
	(
		# Split command and required options from remaining options
		git_command="$1"
		shift

		case "$git_command" in
			diffref) # [<ref_spec>]
				required_options="${1:-1}"
				if [ $# -gt 0 ]; then
					shift
				fi
				options="$required_options --patch --no-prefix --relative"
				to_quickfix='diff_to_quickfix'
				;;
			grep)
				options="--column --line-number"
				to_quickfix='grep_to_quickfix'
				;;
			stash) # show
				required_options="$1"
				shift
				options="$required_options --patch --no-prefix --relative"
				to_quickfix='diff_to_quickfix'
				;;
			*)
				options='--patch --no-prefix --relative'
				to_quickfix='diff_to_quickfix'
				;;
		esac

		git_diff="$(git "$git_command" $options "$@")"

		if [ "$to_quickfix" = '' ]; then
			echo "$git_diff"
		else
			echo "$git_diff" | "$to_quickfix"
		fi
	)
else
	diff_to_quickfix
fi
